# 1.数据类型

# 整型

### 有符号

short类型 ：至少16位

int类型： 至少与short一样长

long ：至少32位

long long ：至少64位，至少与long一样长

8位是一个字节

### 无符号

上述的整型都存在一种不能存储负数的无符号变体，优点是可以增大变量能够存储的最大值：
short类型的范围是 -32768~32767 

而无符号版本是0~65535 

只需要添加关键字 ==unsigned== 注意unsigned本身是unsigned int 的缩写！！！

关于溢出(上溢和下溢)问题：

~~~
#include<iostream>
#define ZERO 0
#include<climits>

int main()
{
	using namespace std;
	short sam = SHRT_MAX;
	unsigned short sue = sam;
	cout<<"Sam has "<< sam <<"dollars and Sue has "<<sue;
	
	sam = sam +1;
	sue = sue +1;
	cout<<"Sam has "<< sam <<"dollars and Sue has "<<sue;
	
	sam = ZERO;
	sue = ZERO;
	sam = sam - 1;
	sue = sue - 1;
	cout<<"Sam has "<< sam <<"dollars and Sue has "<<sue;
	
	return 0;
}
~~~

## char类型

存储字符和小整数

'A' 为65 字符A的ASCII码

'a' 为97 字符a的ASCII码

'5' 为53 数字5的ASCII码

' ' 为32  空格字符的ASCII码

'!'为33 感叹号字符的ASCII码

### 转义字符（详细见7.字符常量）

\n 表示换行

\t 水平制表符

\v 垂直制表符

\\ \ 反斜杠\

### signed char  、unsigned char

如果将char作为数值类型 signed char 和unsigned char差异很重要 

前一个范围是 -128 - 127     	后一个范围是 0-255   

## bool类型

表示真和假 

bool的非零值解释为true 将0解释为false

## 浮点类型

浮点数：能够表示带小数部分的数字

float     

double	

long double	

# 2.运算符

## 算术运算符

+运算符是加法

-运算符是减法

*运算符是乘法

/运算符是除法     	行为取决于操作数的类型 如果两个操作数都是整数，则执行整数除法，结果的小数部分被丢弃 ；如果其中有一个数（or两个）是浮点值，小数部分将保留

%运算符是取模

++自增运算符 整数值加1

--自减运算符 整数值减1

## 类型转换

强制类型转换 格式如下

（typename）value    	来自c语言

typename（value）  	  纯粹c++格式

## 关系运算符

| 运算符 | 描述                                                         | 实例              |
| :----- | :----------------------------------------------------------- | :---------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 不为真。 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。   |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 不为真。  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。    |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。   |

## 逻辑运算符

下表显示了 C++ 支持的关系逻辑运算符。

假设变量 A 的值为 1，变量 B 的值为 0，则：

| 运算符 | 描述                                                         | 实例                 |
| :----- | :----------------------------------------------------------- | :------------------- |
| &&     | 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。     | (A && B) 为 false。  |
| \|\|   | 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 | (A \|\| B) 为 true。 |
| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 | !(A && B) 为 true。  |

## ==位运算符==

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p    | q    | p & q | p \| q | p ^ q |
| :--- | :--- | :---- | :----- | :---- |
| 0    | 0    | 0     | 0      | 0     |
| 0    | 1    | 0     | 1      | 1     |
| 1    | 1    | 1     | 1      | 0     |
| 1    | 0    | 0     | 1      | 1     |

假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：

A = 0011 1100

B = 0000 1101

\-----------------

A&B = 0000 1100

A|B = 0011 1101

A^B = 0011 0001

~A = 1100 0011

下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与操作，按二进制位进行"与"运算。运算规则：`0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |
| \|     | 按位或运算符，按二进制位进行"或"运算。运算规则：`0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \| B) 将得到 61，即为 0011 1101                           |
| ^      | 异或运算符，按二进制位进行"异或"运算。运算规则：`0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |
| ~      | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=-2;    ~0=-1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| ==<<== | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |
| ==>>== | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 | A >> 2 将得到 15，即为 0000 1111                             |

## 赋值运算符

| 运算符 | 描述                                                         | 实例                            |
| :----- | :----------------------------------------------------------- | :------------------------------ |
| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |
| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |
| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |
| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |
| \|=    | 按位或且赋值运算符                                           | C \|= 2 等同于 C = C \| 2       |

# 3.数组

声明：

数组中数的类型 数组名 [元素数]

即：typeName arrayName  [arrarSize]

 索引从0开始，故最后一个元素的索引比长度少1

## 初始化

只有定义数组时才能初始化数组，也不能将一个数组赋值给另一个数组；

如果只对数组的一部分进行初始化，剩下的赋值为0；

初始化数组可以省略等号 double array[4] {1.2 1.23 1.32 1.65}  可以不在大括号内包含任何东西，这将所有元素设置为0

vector是数组的替代品

# 4.字符串

c风格字符串： 可以将字符串存在char数组中，每个字符都位于自己的数组元素中 
==c风格的字符串以空字符结尾   被写作\0 ASCII码为0==

~~~
char cat[8] = {'f','a','t','e','s','a','\0'};
char dog[8] = {'b','e','a','u','x',' ','i','i'};
//这两个数组都是char数组 但只有第一个是字符串
char bird [11] = "Mr.Cheeps";
char fish[] = "Bubbles";

~~~

sizeof（）指出整个数组的长度 

strlen是返回存储在数组的字符串的长度  使用strlen()需要头文件#include<cstring>

## 输入

面向行的输入  getline（） 函数读取整行，使用回车输入的换行符来确定输入结尾，调用该函数可以使用cin.getline（） 该函数有两个参数，第一个参数是用来存储输入行的数组的名称，第二个参数是读取的字符数

# 5.变量类型

·左值：指向内存位置的表达式被称为左值表达式，左值可以出现在赋值号的左或右边

·右值：右值指的是存储在内存中某些地址的数值，右值是不能对其进行赋值的表达式，也就是说右值可以出现在赋值号的右边，但是不能出现在赋值号的左侧

# 6.变量的作用域

一般来说有三个地方可以定义变量：

- 在函数或一个代码块内部声明的变量，称为**局部变量**。
- 在函数参数的定义中声明的变量，称为**形式参数**。
- 在所有函数外部声明的变量，称为**全局变量**。

作用域是程序的一个区域，变量的作用域可以分为以下几种：

- **局部作用域**：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。
- **全局作用域**：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。==全局变量在程序开始时被创建，在程序结束时被销毁。==
- **块作用域**：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。
- **类作用域**：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。==类作用域变量的生命周期与类的生命周期相同。==

**注意：**如果在内部作用域中声明的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部作用域中的变量。

局部变量：

~~~
#include <iostream>
using namespace std;
 
int main ()
{
  // 局部变量声明
  int a, b;
  int c;
 
  // 实际初始化
  a = 10;
  b = 20;
  c = a + b;
 
  cout << c;
 
  return 0;
}
~~~

全局变量：

~~~
#include <iostream>
using namespace std;
 
// 全局变量声明
int g;
 
int main ()
{
  // 局部变量声明
  int a, b;
 
  // 实际初始化
  a = 10;
  b = 20;
  g = a + b;
 
  cout << g;
 
  return 0;
}
~~~

# 7.常量

## 整数常量

不带前缀默认是十进制

后缀是U表示无符号整数；L表示长整数，后缀可以是大写或小写；后缀可以是u和l的组合

## 浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

## 布尔常量

true

false

## 字符常量

字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 **char** 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：

| 转义序列   | 含义                       |
| :--------- | :------------------------- |
| \\         | \ 字符                     |
| \'         | ' 字符                     |
| \"         | " 字符                     |
| \?         | ? 字符                     |
| \a         | 警报铃声                   |
| \b         | 退格键                     |
| \f         | 换页符                     |
| \n         | 换行符                     |
| \r         | 回车                       |
| \t         | 水平制表符                 |
| \v         | 垂直制表符                 |
| \ooo       | 一到三位的八进制数         |
| \xhh . . . | 一个或多个数字的十六进制数 |

## 字符串常量

字符串字面值或常量是括在双引号 **""** 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以使用 **\** 做分隔符，把一个很长的字符串常量进行分行。

下面的实例显示了一些字符串常量：

~~~\#include <iostream>
#include <string>
using namespace std;

int main() 
{
  string greeting = "hello, runoob";
  cout << greeting;
  cout << "\n";   // 换行符
  string greeting2 = "hello, \
            runoob";
  cout << greeting2;
  return 0;
}
~~~

# 8.定义常量

·使用#define定义

·使用const关键字

# 9.存储类 ？？

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：

- **auto**：这是默认的存储类说明符，通常可以省略不写。auto 指定的变量具有自动存储期，即它们的生命周期仅限于定义它们的块（block）。auto 变量通常在栈上分配。
- **register**：用于建议编译器将变量存储在CPU寄存器中以提高访问速度。在 C++11 及以后的版本中，register 已经是一个废弃的特性，不再具有实际作用。
- **static**：用于定义具有静态存储期的变量或函数，它们的生命周期贯穿整个程序的运行期。在函数内部，static变量的值在函数调用之间保持不变。在文件内部或全局作用域，static变量具有内部链接，只能在定义它们的文件中访问。
- **extern**：用于声明具有==外部链接==的变量或函数，它们可以在多个文件之间共享。默认情况下，全局变量和函数具有 extern 存储类。在一个文件中使用extern声明另一个文件中定义的全局变量或函数，可以实现跨文件共享。
- **mutable (C++11)**：用于修饰类中的成员变量，允许在const成员函数中修改这些变量的值。通常用于缓存或计数器等需要在const上下文中修改的数据。
- **thread_local (C++11)**：用于定义具有线程局部存储期的变量，每个线程都有自己的独立副本。线程局部变量的生命周期与线程的生命周期相同

从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。

中的存储类说明符为程序员提供了控制变量和函数生命周期及可见性的手段。

合理使用存储类说明符可以提高程序的可维护性和性能。

从 C++11 开始，register 已经失去了原有的作用，而 mutable 和 thread_local 则是新引入的特性，用于解决特定的编程问题。

asdasasdsaaasdsa
